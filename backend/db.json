{
  "users": [
    {
      "id": 1,
      "email": "admin@blog.com",
      "password": "$2b$12$/BDAM7vvP/l9EivK5ezYz.3z/xJO78La7t2uX1SMctB19Dbp6fkc2",
      "avatar": "/users/1/avatar.svg",
      "username": "admin",
      "bio": "????????这里是神秘人管理员，把不听话的小朋友抓到小黑屋里面",
      "role": "admin",
      "created_at": "2024-01-01T00:00:00Z",
      "followers_count": 157,
      "following_count": 24
    },
    {
      "id": 2,
      "email": "test@example.com",
      "password": "$2b$12$/BDAM7vvP/l9EivK5ezYz.3z/xJO78La7t2uX1SMctB19Dbp6fkc2",
      "avatar": "/users/2/avatar.svg",
      "username": "user1",
      "bio": "",
      "role": "user",
      "created_at": "2024-06-01T00:00:00Z",
      "followers_count": 12,
      "following_count": 7
    },
    {
      "id": 3,
      "email": "developer@blog.com",
      "password": "$2b$12$/BDAM7vvP/l9EivK5ezYz.3z/xJO78La7t2uX1SMctB19Dbp6fkc2",
      "avatar": "/users/3/avatar.svg",
      "username": "前端开发者",
      "bio": "专注于前端技术，喜欢分享Vue、React等前端框架的使用心得。",
      "role": "user",
      "created_at": "2024-02-15T00:00:00Z",
      "followers_count": 90,
      "following_count": 45
    },
    {
      "id": 4,
      "email": "backend@blog.com",
      "password": "$2b$12$/BDAM7vvP/l9EivK5ezYz.3z/xJO78La7t2uX1SMctB19Dbp6fkc2",
      "avatar": "/users/4/avatar.svg",
      "username": "后端工程师",
      "bio": "后端技术爱好者，专注于Python、Node.js等后端技术栈。",
      "role": "user",
      "created_at": "2024-03-10T00:00:00Z",
      "followers_count": 69,
      "following_count": 34
    },
    {
      "id": 5,
      "email": "designer@blog.com",
      "password": "$2b$12$/BDAM7vvP/l9EivK5ezYz.3z/xJO78La7t2uX1SMctB19Dbp6fkc2",
      "avatar": "/users/5/avatar.svg",
      "username": "UI设计师",
      "bio": "UI/UX设计师，关注用户体验和界面设计，分享设计心得和工具使用技巧。",
      "role": "user",
      "created_at": "2024-04-20T00:00:00Z",
      "followers_count": 135,
      "following_count": 78
    },
    {
      "id": 6,
      "email": "123@qq.com",
      "password": "$2b$12$/BDAM7vvP/l9EivK5ezYz.3z/xJO78La7t2uX1SMctB19Dbp6fkc2",
      "avatar": "/users/6/avatar.svg",
      "username": "新手程序员",
      "bio": "刚入门的程序员，正在学习各种技术。",
      "role": "user",
      "created_at": "2024-06-16T00:00:00Z",
      "followers_count": 3,
      "following_count": 13
    },
    {
      "id": 7,
      "email": "111@qq.com",
      "password": "$2b$12$HwILDdXIBiJWyGcTqfGSJuI9hh7OZtDg6Hov3jO28HL2vD/Pj6Jfe",
      "avatar": null,
      "following_count": 4
    }
  ],
  "posts": [
    {
      "id": 1,
      "slug": "vue3-composition-api-guide",
      "title": "Vue 3 Composition API 完全指南",
      "content": "# Vue 3 Composition API 完全指南\n\n## 什么是 Composition API\n\nComposition API 是 Vue 3 中引入的一套新的 API，它提供了一种更灵活的方式来组织组件逻辑。\n\n## 基本用法\n\n```javascript\nimport { ref, reactive, computed } from 'vue'\n\nexport default {\n  setup() {\n    const count = ref(0)\n    const state = reactive({ name: 'Vue 3' })\n    \n    const doubleCount = computed(() => count.value * 2)\n    \n    function increment() {\n      count.value++\n    }\n    \n    return {\n      count,\n      state,\n      doubleCount,\n      increment\n    }\n  }\n}\n```\n\n## 优势\n\n1. **更好的逻辑复用**：通过组合函数实现逻辑复用\n2. **更好的类型推导**：TypeScript 支持更好\n3. **更灵活的代码组织**：相关逻辑可以组织在一起\n\n## 总结\n\nComposition API 为 Vue 3 带来了更强大的功能和更好的开发体验。",
      "summary": "深入了解 Vue 3 Composition API 的使用方法和最佳实践",
      "cover": null,
      "authorId": 3,
      "likes_count": 44,
      "views_count": 1252,
      "comments_count": 8,
      "bookmarks_count": 13,
      "tags": [
        "Vue",
        "JavaScript",
        "前端开发"
      ],
      "created_at": "2025-05-17T14:38:00.000000Z",
      "updated_at": "2025-05-17T14:38:00.000000Z",
      "status": "published",
      "likes": 5,
      "author": {
        "id": 3,
        "username": "前端开发者",
        "email": "developer@blog.com",
        "avatar": "/users/3/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-19T08:08:38.244552Z"
      }
    },
    {
      "id": 2,
      "slug": "python-fastapi-tutorial",
      "title": "FastAPI 快速入门教程",
      "content": "# FastAPI 快速入门教程\n\n## 简介\n\nFastAPI 是一个现代、快速的 Python Web 框架，用于构建 API。\n\n## 安装\n\n```bash\npip install fastapi uvicorn\n```\n\n## 第一个应用\n\n```python\nfrom fastapi import FastAPI\n\napp = FastAPI()\n\n@app.get(\"/\")\ndef read_root():\n    return {\"Hello\": \"World\"}\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}\n```\n\n## 运行应用\n\n```bash\nuvicorn main:app --reload\n```\n\n## 特性\n\n- 自动生成 API 文档\n- 类型检查\n- 高性能\n- 易于使用\n\n这就是 FastAPI 的基本使用方法！",
      "summary": "学习如何使用 FastAPI 构建现代化的 Python Web API",
      "cover": null,
      "authorId": 4,
      "likes_count": 32,
      "views_count": 858,
      "comments_count": 3,
      "bookmarks_count": 8,
      "tags": [
        "Python",
        "FastAPI",
        "后端开发",
        "API"
      ],
      "created_at": "2025-05-04T15:43:00.000000Z",
      "updated_at": "2025-05-04T15:43:00.000000Z",
      "status": "published",
      "author": {
        "id": 4,
        "username": "后端工程师",
        "email": "backend@blog.com",
        "avatar": "/users/4/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-19T07:22:33.194900Z"
      }
    },
    {
      "id": 3,
      "slug": "ui-design-principles",
      "title": "现代UI设计的基本原则",
      "content": "# 现代UI设计的基本原则\n\n## 简洁性\n\n好的设计应该是简洁的，避免不必要的装饰和复杂性。\n\n## 一致性\n\n保持设计元素的一致性，包括颜色、字体、间距等。\n\n## 可用性\n\n设计应该以用户为中心，确保界面易于使用和理解。\n\n## 视觉层次\n\n通过大小、颜色、对比度等建立清晰的视觉层次。\n\n## 响应式设计\n\n确保设计在不同设备和屏幕尺寸上都能良好显示。\n\n## 总结\n\n遵循这些基本原则，可以创造出更好的用户体验。",
      "summary": "了解现代UI设计的核心原则和最佳实践",
      "cover": null,
      "authorId": 5,
      "likes_count": 28,
      "views_count": 646,
      "comments_count": 1,
      "bookmarks_count": 7,
      "tags": [
        "UI设计",
        "用户体验",
        "设计原则"
      ],
      "created_at": "2025-04-19T08:03:00.000000Z",
      "updated_at": "2025-04-19T08:03:00.000000Z",
      "status": "published",
      "likes": 7,
      "author": {
        "id": 5,
        "username": "UI设计师",
        "email": "designer@blog.com",
        "avatar": "/users/5/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": true,
      "view_records": {
        "127.0.0.1": "2025-06-18T19:35:11.641002Z"
      }
    },
    {
      "id": 4,
      "slug": "react-hooks-best-practices",
      "title": "React Hooks 最佳实践指南",
      "content": "# React Hooks 最佳实践指南\n\n## 引言\n\nReact Hooks 自 React 16.8 版本引入以来，彻底改变了我们编写 React 组件的方式。本文将分享一些 React Hooks 的最佳实践。\n\n## 1. useState 的正确使用\n\n### 避免直接修改状态\n\n```javascript\n// ❌ 错误做法\nconst [user, setUser] = useState({ name: 'John', age: 25 });\nuser.age = 26; // 直接修改\n\n// ✅ 正确做法\nsetUser(prevUser => ({ ...prevUser, age: 26 }));\n```\n\n### 使用函数式更新\n\n```javascript\n// ✅ 当新状态依赖于前一个状态时\nsetCount(prevCount => prevCount + 1);\n```\n\n## 2. useEffect 的优化\n\n### 正确设置依赖数组\n\n```javascript\n// ✅ 包含所有依赖\nuseEffect(() => {\n  fetchUserData(userId);\n}, [userId]);\n\n// ✅ 空依赖数组表示只在挂载时执行\nuseEffect(() => {\n  setupEventListeners();\n  return () => cleanupEventListeners();\n}, []);\n```\n\n### 避免无限循环\n\n```javascript\n// ❌ 可能导致无限循环\nconst [data, setData] = useState([]);\nuseEffect(() => {\n  setData([...data, newItem]);\n}, [data]);\n\n// ✅ 使用函数式更新\nuseEffect(() => {\n  setData(prevData => [...prevData, newItem]);\n}, [newItem]);\n```\n\n## 3. 自定义 Hooks\n\n### 提取可复用逻辑\n\n```javascript\n// 自定义 Hook：useLocalStorage\nfunction useLocalStorage(key, initialValue) {\n  const [storedValue, setStoredValue] = useState(() => {\n    try {\n      const item = window.localStorage.getItem(key);\n      return item ? JSON.parse(item) : initialValue;\n    } catch (error) {\n      return initialValue;\n    }\n  });\n\n  const setValue = (value) => {\n    try {\n      setStoredValue(value);\n      window.localStorage.setItem(key, JSON.stringify(value));\n    } catch (error) {\n      console.error('Error saving to localStorage:', error);\n    }\n  };\n\n  return [storedValue, setValue];\n}\n```\n\n## 4. 性能优化\n\n### 使用 useMemo 和 useCallback\n\n```javascript\n// ✅ 缓存计算结果\nconst expensiveValue = useMemo(() => {\n  return computeExpensiveValue(a, b);\n}, [a, b]);\n\n// ✅ 缓存函数引用\nconst handleClick = useCallback(() => {\n  doSomething(id);\n}, [id]);\n```\n\n## 5. 错误处理\n\n```javascript\nfunction useAsyncData(url) {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const response = await fetch(url);\n        if (!response.ok) {\n          throw new Error('Network response was not ok');\n        }\n        const result = await response.json();\n        setData(result);\n      } catch (err) {\n        setError(err.message);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [url]);\n\n  return { data, loading, error };\n}\n```\n\n## 总结\n\nReact Hooks 为我们提供了强大而灵活的状态管理和副作用处理能力。遵循这些最佳实践，可以帮助我们写出更清晰、更高效的 React 代码。\n\n记住：\n- 始终遵循 Hooks 的规则\n- 正确设置依赖数组\n- 适当使用性能优化 Hooks\n- 提取可复用的自定义 Hooks\n- 做好错误处理\n\n希望这些实践对你的 React 开发有所帮助！",
      "summary": "深入探讨 React Hooks 的最佳实践，包括 useState、useEffect 的正确使用方法，自定义 Hooks 的创建，以及性能优化技巧。",
      "cover": null,
      "authorId": 2,
      "likes_count": 28,
      "views_count": 166,
      "comments_count": 0,
      "bookmarks_count": 13,
      "tags": [
        "React",
        "Hooks",
        "JavaScript",
        "前端开发",
        "最佳实践"
      ],
      "status": "published",
      "created_at": "2025-04-15T16:54:00.000000Z",
      "updated_at": "2025-04-15T16:54:00.000000Z",
      "author": {
        "id": 2,
        "username": "user1",
        "email": "test@example.com",
        "avatar": "/users/2/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-19T08:08:38.290877Z"
      }
    },
    {
      "id": 6,
      "slug": "python-data-analysis-pandas",
      "title": "Python 数据分析：Pandas 完全指南",
      "content": "# Python 数据分析：Pandas 完全指南\n\n## 简介\n\nPandas 是 Python 中最强大的数据分析库之一，提供了高性能、易用的数据结构和数据分析工具。本文将全面介绍 Pandas 的核心功能。\n\n## 1. 数据结构\n\n### Series\n\n```python\nimport pandas as pd\nimport numpy as np\n\n# 创建 Series\ns = pd.Series([1, 3, 5, np.nan, 6, 8])\nprint(s)\n\n# 带索引的 Series\ns = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])\nprint(s)\n```\n\n### DataFrame\n\n```python\n# 从字典创建 DataFrame\ndata = {\n    'Name': ['Alice', 'Bob', 'Charlie', 'Diana'],\n    'Age': [25, 30, 35, 28],\n    'City': ['New York', 'London', 'Tokyo', 'Paris']\n}\ndf = pd.DataFrame(data)\nprint(df)\n\n# 从 CSV 文件读取\ndf = pd.read_csv('data.csv')\n```\n\n## 2. 数据读取和写入\n\n### 读取数据\n\n```python\n# CSV 文件\ndf = pd.read_csv('file.csv')\n\n# Excel 文件\ndf = pd.read_excel('file.xlsx', sheet_name='Sheet1')\n\n# JSON 文件\ndf = pd.read_json('file.json')\n\n# SQL 数据库\nimport sqlite3\nconn = sqlite3.connect('database.db')\ndf = pd.read_sql_query('SELECT * FROM table_name', conn)\n```\n\n### 写入数据\n\n```python\n# 保存为 CSV\ndf.to_csv('output.csv', index=False)\n\n# 保存为 Excel\ndf.to_excel('output.xlsx', index=False)\n\n# 保存为 JSON\ndf.to_json('output.json', orient='records')\n```\n\n## 3. 数据探索\n\n### 基本信息\n\n```python\n# 查看数据形状\nprint(df.shape)\n\n# 查看数据类型\nprint(df.dtypes)\n\n# 查看基本统计信息\nprint(df.describe())\n\n# 查看前几行\nprint(df.head())\n\n# 查看后几行\nprint(df.tail())\n\n# 查看数据信息\nprint(df.info())\n```\n\n### 缺失值检查\n\n```python\n# 检查缺失值\nprint(df.isnull().sum())\n\n# 查看缺失值比例\nprint(df.isnull().mean())\n\n# 可视化缺失值\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\nsns.heatmap(df.isnull(), cbar=True)\nplt.show()\n```\n\n## 4. 数据选择和过滤\n\n### 列选择\n\n```python\n# 选择单列\nages = df['Age']\n\n# 选择多列\nsubset = df[['Name', 'Age']]\n\n# 使用 loc 和 iloc\n# 基于标签的选择\nresult = df.loc[0:2, 'Name':'Age']\n\n# 基于位置的选择\nresult = df.iloc[0:3, 0:2]\n```\n\n### 行过滤\n\n```python\n# 条件过滤\nyoung_people = df[df['Age'] < 30]\n\n# 多条件过滤\nresult = df[(df['Age'] > 25) & (df['City'] == 'New York')]\n\n# 使用 query 方法\nresult = df.query('Age > 25 and City == \"New York\"')\n\n# 使用 isin 方法\ncities = ['New York', 'London']\nresult = df[df['City'].isin(cities)]\n```\n\n## 5. 数据清洗\n\n### 处理缺失值\n\n```python\n# 删除缺失值\ndf_clean = df.dropna()\n\n# 填充缺失值\ndf_filled = df.fillna(0)  # 用 0 填充\ndf_filled = df.fillna(df.mean())  # 用均值填充\ndf_filled = df.fillna(method='ffill')  # 前向填充\n\n# 插值填充\ndf_interpolated = df.interpolate()\n```\n\n### 数据类型转换\n\n```python\n# 转换数据类型\ndf['Age'] = df['Age'].astype('int64')\ndf['Date'] = pd.to_datetime(df['Date'])\n\n# 分类数据\ndf['Category'] = df['Category'].astype('category')\n```\n\n### 重复值处理\n\n```python\n# 检查重复值\nprint(df.duplicated().sum())\n\n# 删除重复值\ndf_unique = df.drop_duplicates()\n\n# 基于特定列删除重复值\ndf_unique = df.drop_duplicates(subset=['Name'])\n```\n\n## 6. 数据变换\n\n### 排序\n\n```python\n# 按单列排序\ndf_sorted = df.sort_values('Age')\n\n# 按多列排序\ndf_sorted = df.sort_values(['City', 'Age'], ascending=[True, False])\n\n# 按索引排序\ndf_sorted = df.sort_index()\n```\n\n### 分组操作\n\n```python\n# 基本分组\ngrouped = df.groupby('City')\n\n# 聚合操作\nresult = df.groupby('City')['Age'].mean()\nresult = df.groupby('City').agg({\n    'Age': ['mean', 'max', 'min'],\n    'Name': 'count'\n})\n\n# 自定义聚合函数\ndef age_range(x):\n    return x.max() - x.min()\n\nresult = df.groupby('City')['Age'].agg(age_range)\n```\n\n### 数据透视表\n\n```python\n# 创建数据透视表\npivot_table = pd.pivot_table(\n    df, \n    values='Age', \n    index='City', \n    columns='Gender', \n    aggfunc='mean'\n)\n\n# 交叉表\ncrosstab = pd.crosstab(df['City'], df['Gender'])\n```\n\n## 7. 字符串操作\n\n```python\n# 字符串方法\ndf['Name_upper'] = df['Name'].str.upper()\ndf['Name_length'] = df['Name'].str.len()\n\n# 字符串分割\ndf[['First', 'Last']] = df['Full_Name'].str.split(' ', expand=True)\n\n# 正则表达式\ndf['Phone_clean'] = df['Phone'].str.replace(r'[^0-9]', '', regex=True)\n\n# 字符串包含\nmask = df['Name'].str.contains('Alice')\nresult = df[mask]\n```\n\n## 8. 时间序列处理\n\n```python\n# 创建时间序列\ndates = pd.date_range('2024-01-01', periods=100, freq='D')\nts = pd.Series(np.random.randn(100), index=dates)\n\n# 时间索引操作\nresult = ts['2024-01']\nresult = ts['2024-01-01':'2024-01-31']\n\n# 重采样\nmonthly = ts.resample('M').mean()\nweekly = ts.resample('W').sum()\n\n# 时间偏移\nts_shifted = ts.shift(1)\nts_lag = ts.shift(-1)\n\n# 滚动窗口\nrolling_mean = ts.rolling(window=7).mean()\nrolling_std = ts.rolling(window=7).std()\n```\n\n## 9. 数据合并\n\n```python\n# 连接 DataFrame\ndf1 = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})\ndf2 = pd.DataFrame({'A': [5, 6], 'B': [7, 8]})\n\n# 垂直连接\nresult = pd.concat([df1, df2], ignore_index=True)\n\n# 水平连接\nresult = pd.concat([df1, df2], axis=1)\n\n# 合并操作\ndf_left = pd.DataFrame({'key': ['A', 'B', 'C'], 'value1': [1, 2, 3]})\ndf_right = pd.DataFrame({'key': ['A', 'B', 'D'], 'value2': [4, 5, 6]})\n\n# 内连接\nresult = pd.merge(df_left, df_right, on='key', how='inner')\n\n# 左连接\nresult = pd.merge(df_left, df_right, on='key', how='left')\n\n# 外连接\nresult = pd.merge(df_left, df_right, on='key', how='outer')\n```\n\n## 10. 性能优化\n\n### 内存优化\n\n```python\n# 查看内存使用\nprint(df.memory_usage(deep=True))\n\n# 优化数据类型\nfor col in df.select_dtypes(include=['int64']).columns:\n    df[col] = pd.to_numeric(df[col], downcast='integer')\n\nfor col in df.select_dtypes(include=['float64']).columns:\n    df[col] = pd.to_numeric(df[col], downcast='float')\n\n# 使用分类数据\ndf['Category'] = df['Category'].astype('category')\n```\n\n### 向量化操作\n\n```python\n# 避免循环，使用向量化操作\n# 慢速方法\nresult = []\nfor index, row in df.iterrows():\n    result.append(row['A'] + row['B'])\n\n# 快速方法\nresult = df['A'] + df['B']\n\n# 使用 apply 方法\ndf['C'] = df.apply(lambda row: row['A'] + row['B'], axis=1)\n\n# 使用 numpy 函数\ndf['D'] = np.where(df['A'] > 0, df['A'], 0)\n```\n\n## 总结\n\nPandas 是数据分析的强大工具，掌握以下核心概念：\n\n1. **数据结构**：Series 和 DataFrame\n2. **数据读写**：支持多种格式\n3. **数据探索**：统计信息和缺失值检查\n4. **数据清洗**：处理缺失值和重复值\n5. **数据变换**：排序、分组、透视\n6. **数据合并**：连接和合并操作\n7. **性能优化**：内存管理和向量化\n\n通过这些技能，你可以高效地处理和分析各种数据集！",
      "summary": "全面介绍 Pandas 数据分析库的核心功能，包括数据结构、读写、清洗、变换、合并等操作，以及性能优化技巧。",
      "cover": null,
      "authorId": 3,
      "likes_count": 42,
      "views_count": 290,
      "comments_count": 0,
      "bookmarks_count": 25,
      "tags": [
        "Python",
        "Pandas",
        "数据分析",
        "数据科学",
        "机器学习"
      ],
      "status": "published",
      "created_at": "2025-04-09T22:34:00.000000Z",
      "updated_at": "2025-04-09T22:34:00.000000Z",
      "author": {
        "id": 3,
        "username": "前端开发者",
        "email": "developer@blog.com",
        "avatar": "/users/3/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-19T07:33:37.273856Z"
      }
    },
    {
      "id": 7,
      "slug": "css-grid-flexbox-layout",
      "title": "CSS Grid 与 Flexbox：现代布局完全指南",
      "content": "# CSS Grid 与 Flexbox：现代布局完全指南\n\n## 引言\n\nCSS Grid 和 Flexbox 是现代 CSS 布局的两大利器。虽然它们都能解决布局问题，但各有特色和适用场景。本文将详细比较这两种布局方式。\n\n## Flexbox：一维布局大师\n\n### 基本概念\n\nFlexbox 是一维布局方法，主要用于在一个方向上（行或列）排列元素。\n\n```css\n.container {\n  display: flex;\n  /* 主轴方向 */\n  flex-direction: row; /* row | row-reverse | column | column-reverse */\n  /* 主轴对齐 */\n  justify-content: center; /* flex-start | flex-end | center | space-between | space-around | space-evenly */\n  /* 交叉轴对齐 */\n  align-items: center; /* flex-start | flex-end | center | stretch | baseline */\n  /* 换行 */\n  flex-wrap: wrap; /* nowrap | wrap | wrap-reverse */\n}\n```\n\n### 常用属性\n\n#### 容器属性\n\n```css\n.flex-container {\n  display: flex;\n  \n  /* 简写属性 */\n  flex-flow: row wrap; /* flex-direction + flex-wrap */\n  \n  /* 多行对齐 */\n  align-content: space-between;\n  \n  /* 间距 */\n  gap: 1rem; /* 现代浏览器支持 */\n}\n```\n\n#### 项目属性\n\n```css\n.flex-item {\n  /* 放大比例 */\n  flex-grow: 1;\n  \n  /* 缩小比例 */\n  flex-shrink: 1;\n  \n  /* 基础大小 */\n  flex-basis: auto;\n  \n  /* 简写 */\n  flex: 1 1 auto; /* grow shrink basis */\n  \n  /* 单独对齐 */\n  align-self: flex-end;\n  \n  /* 顺序 */\n  order: 2;\n}\n```\n\n### 实用示例\n\n#### 1. 导航栏布局\n\n```css\n.navbar {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding: 1rem;\n}\n\n.nav-links {\n  display: flex;\n  gap: 2rem;\n  list-style: none;\n}\n```\n\n```html\n<nav class=\"navbar\">\n  <div class=\"logo\">Logo</div>\n  <ul class=\"nav-links\">\n    <li><a href=\"#\">Home</a></li>\n    <li><a href=\"#\">About</a></li>\n    <li><a href=\"#\">Contact</a></li>\n  </ul>\n</nav>\n```\n\n#### 2. 卡片布局\n\n```css\n.card {\n  display: flex;\n  flex-direction: column;\n  height: 300px;\n}\n\n.card-header {\n  flex-shrink: 0;\n}\n\n.card-body {\n  flex-grow: 1;\n  overflow-y: auto;\n}\n\n.card-footer {\n  flex-shrink: 0;\n  margin-top: auto;\n}\n```\n\n#### 3. 居中布局\n\n```css\n.center-container {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  min-height: 100vh;\n}\n```\n\n## CSS Grid：二维布局专家\n\n### 基本概念\n\nCSS Grid 是二维布局系统，可以同时处理行和列。\n\n```css\n.grid-container {\n  display: grid;\n  \n  /* 定义列 */\n  grid-template-columns: 1fr 2fr 1fr;\n  /* 或者 */\n  grid-template-columns: repeat(3, 1fr);\n  grid-template-columns: 200px auto 100px;\n  \n  /* 定义行 */\n  grid-template-rows: 100px auto 50px;\n  \n  /* 间距 */\n  gap: 1rem;\n  /* 或者分别设置 */\n  row-gap: 1rem;\n  column-gap: 2rem;\n}\n```\n\n### 网格线和区域\n\n#### 使用网格线\n\n```css\n.grid-item {\n  /* 指定位置 */\n  grid-column-start: 1;\n  grid-column-end: 3;\n  grid-row-start: 1;\n  grid-row-end: 2;\n  \n  /* 简写 */\n  grid-column: 1 / 3;\n  grid-row: 1 / 2;\n  \n  /* 更简写 */\n  grid-area: 1 / 1 / 2 / 3; /* row-start / col-start / row-end / col-end */\n}\n```\n\n#### 使用命名区域\n\n```css\n.grid-container {\n  display: grid;\n  grid-template-areas:\n    \"header header header\"\n    \"sidebar main main\"\n    \"footer footer footer\";\n  grid-template-columns: 200px 1fr 1fr;\n  grid-template-rows: 80px 1fr 60px;\n}\n\n.header { grid-area: header; }\n.sidebar { grid-area: sidebar; }\n.main { grid-area: main; }\n.footer { grid-area: footer; }\n```\n\n### 响应式网格\n\n#### 自动适应\n\n```css\n.responsive-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n  gap: 1rem;\n}\n\n/* auto-fill vs auto-fit */\n.auto-fill {\n  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));\n}\n\n.auto-fit {\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n}\n```\n\n#### 媒体查询配合\n\n```css\n.adaptive-grid {\n  display: grid;\n  gap: 1rem;\n}\n\n/* 移动端 */\n@media (max-width: 768px) {\n  .adaptive-grid {\n    grid-template-columns: 1fr;\n  }\n}\n\n/* 平板 */\n@media (min-width: 769px) and (max-width: 1024px) {\n  .adaptive-grid {\n    grid-template-columns: repeat(2, 1fr);\n  }\n}\n\n/* 桌面端 */\n@media (min-width: 1025px) {\n  .adaptive-grid {\n    grid-template-columns: repeat(3, 1fr);\n  }\n}\n```\n\n### 实用示例\n\n#### 1. 经典网页布局\n\n```css\n.page-layout {\n  display: grid;\n  grid-template-areas:\n    \"header header\"\n    \"sidebar main\"\n    \"footer footer\";\n  grid-template-columns: 250px 1fr;\n  grid-template-rows: auto 1fr auto;\n  min-height: 100vh;\n}\n\n.header {\n  grid-area: header;\n  background: #333;\n  color: white;\n  padding: 1rem;\n}\n\n.sidebar {\n  grid-area: sidebar;\n  background: #f4f4f4;\n  padding: 1rem;\n}\n\n.main {\n  grid-area: main;\n  padding: 1rem;\n}\n\n.footer {\n  grid-area: footer;\n  background: #333;\n  color: white;\n  padding: 1rem;\n  text-align: center;\n}\n```\n\n#### 2. 图片画廊\n\n```css\n.gallery {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n  gap: 1rem;\n}\n\n.gallery-item {\n  aspect-ratio: 1;\n  overflow: hidden;\n  border-radius: 8px;\n}\n\n.gallery-item img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  transition: transform 0.3s ease;\n}\n\n.gallery-item:hover img {\n  transform: scale(1.1);\n}\n```\n\n#### 3. 复杂卡片布局\n\n```css\n.card-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));\n  gap: 2rem;\n}\n\n.card {\n  display: grid;\n  grid-template-rows: auto 1fr auto;\n  border: 1px solid #ddd;\n  border-radius: 8px;\n  overflow: hidden;\n}\n\n.card-image {\n  aspect-ratio: 16/9;\n  background-size: cover;\n  background-position: center;\n}\n\n.card-content {\n  padding: 1rem;\n}\n\n.card-actions {\n  padding: 1rem;\n  border-top: 1px solid #eee;\n  display: flex;\n  justify-content: space-between;\n}\n```\n\n## Grid vs Flexbox：如何选择？\n\n### 使用 Flexbox 的场景\n\n1. **一维布局**：导航栏、按钮组\n2. **内容驱动**：不知道确切的项目数量\n3. **组件内部布局**：卡片内容排列\n4. **居中对齐**：简单的居中需求\n\n```css\n/* 适合 Flexbox */\n.button-group {\n  display: flex;\n  gap: 0.5rem;\n}\n\n.form-row {\n  display: flex;\n  align-items: center;\n  gap: 1rem;\n}\n```\n\n### 使用 Grid 的场景\n\n1. **二维布局**：整体页面结构\n2. **布局驱动**：预先定义的网格结构\n3. **复杂对齐**：需要精确控制位置\n4. **响应式设计**：复杂的响应式需求\n\n```css\n/* 适合 Grid */\n.page-layout {\n  display: grid;\n  grid-template-areas: \"header header\" \"sidebar main\" \"footer footer\";\n}\n\n.product-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));\n}\n```\n\n### 组合使用\n\n```css\n/* Grid 用于整体布局 */\n.layout {\n  display: grid;\n  grid-template-columns: 250px 1fr;\n  grid-template-rows: auto 1fr;\n}\n\n/* Flexbox 用于组件内部 */\n.header {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.card {\n  display: flex;\n  flex-direction: column;\n}\n```\n\n## 现代布局技巧\n\n### 1. 粘性页脚\n\n```css\n.page {\n  display: grid;\n  grid-template-rows: auto 1fr auto;\n  min-height: 100vh;\n}\n```\n\n### 2. 等高列\n\n```css\n.columns {\n  display: grid;\n  grid-template-columns: repeat(3, 1fr);\n  gap: 2rem;\n}\n```\n\n### 3. 响应式间距\n\n```css\n.container {\n  display: grid;\n  gap: clamp(1rem, 4vw, 3rem);\n}\n```\n\n### 4. 内在响应式\n\n```css\n.responsive-container {\n  display: grid;\n  grid-template-columns: repeat(auto-fit, minmax(min(250px, 100%), 1fr));\n}\n```\n\n## 总结\n\n- **Flexbox**：一维布局，内容驱动，适合组件内部\n- **Grid**：二维布局，布局驱动，适合整体结构\n- **组合使用**：Grid 负责大局，Flexbox 处理细节\n- **现代特性**：利用 `gap`、`clamp()`、`min()` 等新特性\n\n掌握这两种布局方式，你就能应对几乎所有的现代网页布局需求！",
      "summary": "深入对比 CSS Grid 和 Flexbox 两种现代布局方式，详细介绍各自特点、适用场景和实战技巧，帮助开发者选择合适的布局方案。",
      "cover": null,
      "authorId": 1,
      "likes_count": 38,
      "views_count": 203,
      "comments_count": 1,
      "bookmarks_count": 23,
      "tags": [
        "CSS",
        "Grid",
        "Flexbox",
        "布局",
        "响应式设计"
      ],
      "status": "published",
      "created_at": "2025-03-15T20:09:00.000000Z",
      "updated_at": "2025-06-18T18:09:35.525879Z",
      "likes": 1,
      "author": {
        "id": 1,
        "username": "admin",
        "email": "admin@blog.com",
        "avatar": "/users/1/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-19T07:50:05.222588Z"
      }
    },
    {
      "id": 8,
      "slug": "-1750234807005",
      "title": "测试文章",
      "content": "# TypeScript 高级类型系统详解\n\nTypeScript 的类型系统是其最强大的特性之一，它不仅提供了基本的类型检查，还支持许多高级类型特性，让我们能够编写更安全、更可维护的代码。\n\n标签：TypeScript, 类型系统, 前端开发, JavaScript\n\n## 联合类型与交叉类型\n\n### 联合类型 (Union Types)\n\n联合类型表示一个值可以是几种类型之一：\n\n```typescript\ntype StringOrNumber = string | number;\n\nfunction formatValue(value: StringOrNumber): string {\n  if (typeof value === 'string') {\n    return value.toUpperCase();\n  }\n  return value.toString();\n}\n```\n\n### 交叉类型 (Intersection Types)\n\n交叉类型将多个类型合并为一个类型：\n\n```typescript\ninterface Person {\n  name: string;\n  age: number;\n}\n\ninterface Employee {\n  employeeId: string;\n  department: string;\n}\n\ntype PersonEmployee = Person & Employee;\n\nconst employee: PersonEmployee = {\n  name: \"张三\",\n  age: 30,\n  employeeId: \"E001\",\n  department: \"开发部\"\n};\n```\n\n## 泛型 (Generics)\n\n泛型允许我们创建可重用的组件，这些组件可以处理多种类型：\n\n```typescript\nfunction identity<T>(arg: T): T {\n  return arg;\n}\n\n// 使用泛型\nconst stringResult = identity<string>(\"hello\");\nconst numberResult = identity<number>(42);\n\n// 类型推断\nconst autoResult = identity(\"world\"); // TypeScript 自动推断为 string\n```\n\n### 泛型约束\n\n```typescript\ninterface Lengthwise {\n  length: number;\n}\n\nfunction loggingIdentity<T extends Lengthwise>(arg: T): T {\n  console.log(arg.length); // 现在我们知道它有 length 属性\n  return arg;\n}\n\nloggingIdentity(\"hello\"); // ✅ 字符串有 length 属性\nloggingIdentity([1, 2, 3]); // ✅ 数组有 length 属性\n// loggingIdentity(3); // ❌ 数字没有 length 属性\n```\n\n## 条件类型 (Conditional Types)\n\n条件类型根据条件选择类型：\n\n```typescript\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype Example1 = NonNullable<string | null>; // string\ntype Example2 = NonNullable<number | undefined>; // number\n```\n\n### 分布式条件类型\n\n```typescript\ntype ToArray<T> = T extends any ? T[] : never;\n\ntype StringArray = ToArray<string>; // string[]\ntype NumberArray = ToArray<number>; // number[]\ntype UnionArray = ToArray<string | number>; // string[] | number[]\n```\n\n## 映射类型 (Mapped Types)\n\n映射类型基于旧类型创建新类型：\n\n```typescript\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\ninterface User {\n  id: number;\n  name: string;\n  email: string;\n}\n\ntype ReadonlyUser = Readonly<User>;\ntype PartialUser = Partial<User>;\n```\n\n### 自定义映射类型\n\n```typescript\ntype Getters<T> = {\n  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];\n};\n\ntype UserGetters = Getters<User>;\n// {\n//   getId: () => number;\n//   getName: () => string;\n//   getEmail: () => string;\n// }\n```\n\n## 模板字面量类型\n\nTypeScript 4.1 引入了模板字面量类型：\n\n```typescript\ntype EventName<T extends string> = `on${Capitalize<T>}`;\n\ntype ClickEvent = EventName<\"click\">; // \"onClick\"\ntype HoverEvent = EventName<\"hover\">; // \"onHover\"\n\n// 更复杂的例子\ntype CSSProperty = \"margin\" | \"padding\" | \"border\";\ntype CSSDirection = \"top\" | \"right\" | \"bottom\" | \"left\";\n\ntype CSSPropertyWithDirection = `${CSSProperty}-${CSSDirection}`;\n// \"margin-top\" | \"margin-right\" | \"margin-bottom\" | \"margin-left\" | \n// \"padding-top\" | \"padding-right\" | \"padding-bottom\" | \"padding-left\" | \n// \"border-top\" | \"border-right\" | \"border-bottom\" | \"border-left\"\n```\n\n## 实用工具类型\n\nTypeScript 提供了许多内置的工具类型：\n\n```typescript\ninterface Todo {\n  title: string;\n  description: string;\n  completed: boolean;\n  createdAt: Date;\n}\n\n// Pick - 选择特定属性\ntype TodoPreview = Pick<Todo, \"title\" | \"completed\">;\n\n// Omit - 排除特定属性\ntype TodoInfo = Omit<Todo, \"completed\" | \"createdAt\">;\n\n// Record - 创建具有特定键值类型的对象类型\ntype PageInfo = Record<\"home\" | \"about\" | \"contact\", { title: string; url: string }>;\n\n// ReturnType - 获取函数返回类型\nfunction createUser() {\n  return { id: 1, name: \"张三\", email: \"zhangsan@example.com\" };\n}\n\ntype User = ReturnType<typeof createUser>; // { id: number; name: string; email: string; }\n```\n\n## 类型守卫 (Type Guards)\n\n类型守卫帮助 TypeScript 在运行时确定类型：\n\n```typescript\n// 自定义类型守卫\nfunction isString(value: unknown): value is string {\n  return typeof value === \"string\";\n}\n\nfunction processValue(value: unknown) {\n  if (isString(value)) {\n    // 在这个块中，TypeScript 知道 value 是 string\n    console.log(value.toUpperCase());\n  }\n}\n\n// 使用 in 操作符\ninterface Bird {\n  fly(): void;\n}\n\ninterface Fish {\n  swim(): void;\n}\n\nfunction move(animal: Bird | Fish) {\n  if (\"fly\" in animal) {\n    animal.fly(); // TypeScript 知道这是 Bird\n  } else {\n    animal.swim(); // TypeScript 知道这是 Fish\n  }\n}\n```\n\n## 最佳实践\n\n1. **优先使用类型推断**：让 TypeScript 自动推断类型，只在必要时显式声明。\n\n2. **使用严格模式**：在 `tsconfig.json` 中启用 `strict` 模式。\n\n3. **避免使用 `any`**：尽量使用更具体的类型或 `unknown`。\n\n4. **合理使用泛型**：不要过度使用泛型，保持代码的可读性。\n\n5. **利用工具类型**：充分利用 TypeScript 内置的工具类型。\n\n## 总结\n\nTypeScript 的高级类型系统为我们提供了强大的工具来编写类型安全的代码。通过掌握联合类型、交叉类型、泛型、条件类型、映射类型等特性，我们可以构建更加健壮和可维护的应用程序。\n\n记住，类型系统的目标是在编译时捕获错误，提高代码质量，而不是增加复杂性。合理使用这些高级特性，可以让我们的代码既安全又优雅。\n",
      "summary": "这是一个测试",
      "cover": null,
      "authorId": 2,
      "likes_count": 0,
      "views_count": 5,
      "comments_count": 0,
      "bookmarks_count": 0,
      "tags": [
        "TypeScript",
        "类型系统",
        "前端开发",
        "JavaScript"
      ],
      "status": "published",
      "created_at": "2025-03-08T13:52:00.000000Z",
      "updated_at": "2025-03-08T13:52:00.000000Z",
      "author": {
        "id": 2,
        "username": "user1",
        "email": "test@example.com",
        "avatar": "/users/2/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-18T18:09:46.371959Z"
      }
    },
    {
      "id": 9,
      "slug": "test-2025-time",
      "title": "测试2025年时间功能",
      "content": "这是一篇测试文章，用于验证时间功能是否正常工作。",
      "summary": "测试文章摘要",
      "cover": null,
      "authorId": 2,
      "likes_count": 1,
      "views_count": 19,
      "comments_count": 0,
      "bookmarks_count": 2,
      "tags": [
        "测试",
        "2025"
      ],
      "status": "published",
      "created_at": "2025-06-18T12:48:00.315648Z",
      "updated_at": "2025-06-18T12:48:00.315648Z",
      "author": {
        "id": 2,
        "username": "user1",
        "email": "test@example.com",
        "avatar": "/users/2/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-19T08:08:38.255871Z"
      },
      "likes": 3
    },
    {
      "id": 10,
      "slug": "-1750320010053",
      "title": "层次结构处理系统",
      "content": "---\n作者: Ecank\ntags: \n创建日期:\n  \"{ date }\": \n是否完成: \n文档性质(子/父/无): \n想法: \nkeyword:\ntitle: 7.层次结构处理系统\nmodify: 2025-03-13 17:30\n---\n ## 难点\n[计算机组成原理——存储器容量扩展（字扩展、位扩展、字位扩展）_存储器扩展-CSDN博客](https://blog.csdn.net/m0_50609545/article/details/118310334#:~:text=%E4%BD%8D%E6%89%A9%E5%B1%95%EF%BC%9A%20%E5%8F%AA%E5%8A%A0%E5%A4%A7%E5%AD%97%E9%95%BF%EF%BC%8C%E8%80%8C%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AD%97%E6%95%B0%E4%B8%8E%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%E7%89%87%E5%AD%97%E6%95%B0%E4%B8%80%E8%87%B4%EF%BC%8C%E5%AF%B9%E6%89%80%E6%9C%89%E7%89%87%E5%AD%90%E4%BD%BF%E7%94%A8%E5%85%B1%E5%90%8C%E7%89%87%E9%80%89%E4%BF%A1%E5%8F%B7%EF%BC%9B%20%E5%AD%97%E6%89%A9%E5%B1%95%EF%BC%9A%E4%BB%85%E5%9C%A8%E5%AD%97%E5%90%91%E6%89%A9%E5%85%85%EF%BC%8C%E8%80%8C%E4%BD%8D%E6%95%B0%E4%B8%8D%E5%8F%98%E3%80%82%20%E9%9C%80%E7%94%B1%E7%89%87%E9%80%89%E4%BF%A1%E5%8F%B7%E6%9D%A5%E5%8C%BA%E5%88%86%E5%90%84%E7%89%87%E5%9C%B0%E5%9D%80%E3%80%82%20%E5%AD%97%E4%BD%8D%E6%89%A9%E5%B1%95%EF%BC%9A%E4%B8%80%E4%B8%AA%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%AE%B9%E9%87%8F%E5%81%87%E5%AE%9A%E4%B8%BAM%C3%97N%E4%BD%8D%EF%BC%8C%E8%8B%A5%E4%BD%BF%E7%94%A8l%C3%97k,%E4%BD%8D%E7%9A%84%E8%8A%AF%E7%89%87%20%28l%EF%BC%9CM%EF%BC%8Ck%EF%BC%9CN%29%EF%BC%8C%E9%9C%80%E8%A6%81%E5%9C%A8%E5%AD%97%E5%90%91%E5%92%8C%E4%BD%8D%E5%90%91%E5%90%8C%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%89%A9%E5%B1%95%E3%80%82%20%E6%AD%A4%E6%97%B6%E5%85%B1%E9%9C%80%E8%A6%81%20%28M%2Fl%29%C3%97%20%28N%2Fk%29%E4%B8%AA%E5%AD%98%E5%82%A8%E5%99%A8%E8%8A%AF%20%E7%89%87%E3%80%82)\n\n# 存储器概述和RAM芯片\n## 存储器分类\n1. 按工作性质/存取方式分类\n\t* 随机存取存储器 Random Access Memory (RAM)\n\t\t* 每个单元读写时间一样，且与各单元所在位置无关。如：内存。\n\t\t* （注：原意主要强调地址译码时间相同。现在的DRAM芯片采用行缓冲，因而可能因为位置不同而使访问时间有所差别。）\n\t* 顺序存取存储器 Sequential Access Memory (SAM)\n\t\t* 数据按顺序从存储载体的始端读出或写入，因而存取时间的长短与信息所在位置有关。例如：磁带。 ROM 是 顺序存取\n\t* 直接存取存储器 Direct Access Memory(DAM)\n\t\t* 直接定位到读写数据块，在读写数据块时按顺序进行。如磁盘。\n2. 按存储介质分类\n\t* 半导体存储器：双极型，静态MOS型，动态MOS型\n\t* 磁表面存储器：磁盘（Disk）、磁带 （Tape）\n\t* 光存储器：CD，CD-ROM，DVD\n1. 按信息的可更改性分类\n* 读写存储器（Read / Write Memory)：可读可写\n* 只读存储器（Read Only Memory)：只能读不能写\n2. 按断电后信息的可保存性分类\n* 非易失（不挥发）性存储器(Nonvolatile Memory)\n\t* 信息可一直保留， 不需电源维持。\n\t* （如 ：ROM、磁表面存储器、光存储器等）\n* 易失（挥发）性存储器(Volatile Memory)\n\t* 电源关闭时信息自动丢失。（如：RAM、Cache等）\n3. 按功能/容量/速度/所在位置分类\n\t* 寄存器(Register)\n\t\t* 封装在CPU内，用于存放当前正在执行的指令和使用的数据\n\t\t* 用触发器实现，速度快，容量小（几~几十个）\n\t* 高速缓存(Cache)\n\t\t* 位于CPU内部或附近，用来存放当前要执行的局部程序段和数据\n\t\t* 用SRAM实现，速度可与CPU匹配，容量小（几MB）\n\t\t* 静态随机存取存储器（SRAM）是一种不需要周期性刷新即可保持数据的内存。它通过利用晶体管电路来存储每个比特，因此速度较快。\n\t* 内存储器MM（主存储器Main (Primary) Memory）\n\t\t* 位于CPU之外，用来存放已被启动的程序及所用的数据\n\t\t* 用DRAM实现，速度较快，容量较大（几GB）\n\t\t* 动态随机存取存储器（DRAM）是一种需要周期性刷新以保持数据的内存。它通过电容来存储每个比特，但电容会自然放电，因此需要定期刷新。\n\t* 外存储器AM (辅助存储器Auxiliary / Secondary Storage)\n\t\t* 位于主机之外，用来存放暂不运行的程序、数据或存档文件\n\t\t* 用磁表面或光存储器实现，容量大而速度慢\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241203232319.png)\n## 内存与外存的关系及比较\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204195417.png)\n## 内存储器的分类及应用\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204195531.png)\n- **Cache （缓存）** 提供高速存储，以加速 CPU 访问数据。\n- **主存储器（RAM 随机访问存储器）** 提供临时存储空间，用于存储程序和数据。\n- **BIOS（基本输入输出系统）** 是一种固件，负责在计算机启动时初始化硬件并加载操作系统。 ![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204201455.png)\n* **SRAM与DRAM存储元的存储机理的不同之处：**\n* [计组学习笔记（三）：SRAM与DRAM_dram和sram都采用地址复用技-CSDN博客](https://blog.csdn.net/qq_39378221/article/details/80769404)\n\t* SARM采用触发器工作原理存储数据，数据读出后仍然保持原状，无需再生，但一旦断电，原先存储的数据就会消失。\n\t\t* 其优点包括：信息可以永久保存，前提是不断电；速度快；无需刷新；无需读后再生。\n\t\t* 缺点：功耗大，集成度低，价格高，典型应用是cache。\n\t* DRAM采用电容存储电荷的原理存储数据，由于会发生漏电的情况，所以需要定时刷新，保持数据有效性，而且读操作会使得状态发生改变，如读1时，会发生放电情况，改变数据状态，因此需要通过刷新操作来再生数据，DRAM的速度要比SRAM慢，但功耗小，集成度高，主要用于主存。\n\n## 主存的结构\nMM就是主存，取数据就是左侧CPU和右侧MM之间的交互\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204200320.png)\n* MAR\n\t* MAR叫做存储地址寄存器，保存的是存储单元的地址，其位数反映了存储单元的个数。\n\t* 用个例子来说明下：比如有32个存储单元，而存储单元的地址是用二进制来表示的，那么5位二进制数就可以32个存储单元。那么，MAR的位数就是5位。\n\t* 在实际运用中，我们 知道了MAR的位数，存储单元的个数也可以知道了。\n* MDR\n\t* MDR表示存储数据寄存器，其位数反映存储字长。MDR存放的是从存储元件读出，或者要写入某存储元件的数据（二进制数）。\n\t* 如果MDR=16,，每个存储单元进行访问的时候，数据是16位，那么存储字长就是16位。\n* 读写控制信号来决定这次操作是读还是写\n\n* 地址译码器根据传入的地址，输出地址驱动信号，选中对应的单元  ![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204210019.png)\n## ***重点***  存储器芯片扩容  \n字扩展：存储地址不够了，需要多块DRAM来串联。  \n位扩展：存储字长不够，需要多快DRAM并联。\n### 地址线和数据线的计算\n地址线的计算如图所示\n\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204211409.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204211448.png)\n### ***地址引脚 \n\nDRAM会复用地址引脚，所以需要的引脚是地址线的一半\nSRAM则是地址引脚和地址线的数量一样\n### CS线和WE线\n都是低电频有效\n#### CS线 (Chip Select)\n**CS** 线是 **芯片选择线**（Chip Select），用于确定是否激活某个特定的存储芯片。当 **CS** 信号有效时，存储芯片被选择并且可以进行读写操作。当 **CS** 信号无效时，存储芯片将被禁用，无法进行任何操作。\n- **作用**：控制哪个存储芯片处于激活状态。它通常由 **地址译码器** 生成，基于地址的某些位来选择芯片。多个存储芯片共享同一组地址线，但通过不同的 **CS** 信号来确保在同一时刻只有一个芯片被选中。\n- **工作原理**：\n    - **CS = 0**：表示选中该芯片，芯片可以被访问（读或写操作）。\n    - **CS = 1**：表示禁用该芯片，禁止访问。\n\n#### WE线 (Write Enable)\n\n**WE** 线是 **写使能线**（Write Enable），用于控制存储器的写操作。当 **WE** 信号有效时，数据将写入存储器。如果 **WE** 信号无效，则存储器会忽略写操作，只进行读操作。\n\n- **作用**：控制是否执行写操作。当存储器处于写模式时，WE 信号允许或禁止将数据写入存储器单元。\n- **工作原理**：\n    - **WE = 0**：表示允许写入数据到存储器。\n    - **WE = 1**：表示禁止写入数据，存储器处于只读模式。\n### 字扩展\n* 给定的芯片单元数较小（字数少） \n* 芯片个数=设计要求的存储器容量/选择芯片存储器容量 \n* 三组信号组中地址线的低位段和数据线公用，控制线中R/W公用，由地址线的高位段译码来决定片选信号。\n#### 用1K×8位的DRAM芯片设计2K×8位的DRAM存储器\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204212054.png)\n\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204211706.png)\n[计组期末考试 字位扩展存储器框图_哔哩哔哩_bilibili](https://www.bilibili.com/video/BV1co4y1X7fr/?spm_id_from=333.337.search-card.all.click&vd_source=2f0d04fe34956cc27012e3c25b20197b)\n数据线不变，增加一根地址线来控制选择那一个芯片\n\n### 位扩展\n* 给定的芯片位数较短\n* 芯片个数=设计要求的存储器容量/选择芯片存储器容量\n* 三组信号线中，地址线和控制线公用，而数据线单独分开连接\n\n#### 利用1K×4位的SRAM芯片，设计一个存储容量为1K×8位的SRAM存储器\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204221431.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204221511.png)\n### 字-位扩展\n#### 用 1K × 4位 存储芯片组成 4K × 8位 的存储器\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204221857.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204222530.png)\n### 存储器芯片扩容例题\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204223909.png)\n1. **先将十六进制地址范围写成二进制地址码，并确定其总容量**,下方的就是需要地址范围\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204224741.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241204224810.png)\n这里使用74LS138译码器，A11， A12，A13作为信号接入，需要注意的是，MREQ信号必须在片选信号中体现，该信号的作用是确定该地址访问的是存储器而不是IO接口，如果没有这个信号，那对IO接口的访问的同时也会访问存储器，导致数据冲突。\n\nLS138译码器的输出端，当输出Y4的时候（对应输入为100），选中的是ROM，当输出Y5（对应101）的时候，选中的是RAM。这里需要注意的是，选中RAM要求Y5和A10作与运算，这是因为对RAM而言，不仅要138译码器输出的是Y5，同时也得要求A10为0，这样才能读取RAM（或者说当A10为1的时候，这时对应的是别的存储芯片）；而对ROM而言，其地址线包含A10，即不论A10是0还是1，都能够选中芯片内相应的地址。\n[计算机组成原理第五章----存储器容量的扩展与芯片连接_使用4k*8b的存储芯片扩展成为16k*32b的存储器-CSDN博客](https://blog.csdn.net/weixin_51578598/article/details/121319143)\n不是很懂（0信号选中芯片？）\n## 多模块存储器\n* 一个由若干个模块组成的主存储器是线性编址的。这些地址在各模块中如何安排?\n* 两种方式：一种是顺序方式，一种是交叉方式\n ![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205084519.png)\n*  顺序方式 \n\t* `例`M0－M3共四个模块，则每个模块8个字 \n\t* 顺序方式：  \n\t\t* M0：0—7 \n\t\t* M1：8－15 \n\t\t* M2：16－23 \n\t\t* M3：24－31 \n\t* 5位地址组织如下： X X    X X X 高位选模块，低位选块内地址 \n\t* 特点：某个模块进行存取时，其他模块不工作，优点是某一模块出现故障时，其他模块可以照常工作，通过增添模块来扩充存储器容量比较方便。\n\t* 缺点是各模块串行工作，存储器的带宽受到了限制，无法实现并行数据访问\n* 交叉方式： \n\t* M0：0，4,...除以4余数为0 \n\t* M1：1，5,...除以4余数为1 \n\t* M2：2，6,...除以4余数为2 \n\t* M3：3，7,...除以4余数为3 \n\t* 5位地址组织如下： X X X    X X 高位选块内地址，低位选模块 \n\t* 特点：连续地址分布在相邻的不同模块内，同一个模块内的地址都是不连续的。\n\t* 优点是对连续字的成块传送可实现多模块流水式并行存取，大大提高存储器的带宽。使用场合为成批数据读取。\n### 多模块交叉存储器\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205200313.png)\n#### 例: 设存储器容量为32字，字长64位，模块数m=4，分别用顺序方式和交叉方式进行组织。存储周期T=200ns，数据总线宽度为64位，总线传送周期=50ns。若连续读出4个字，问顺序存储器和交叉存储器的带宽各是多少?\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205200733.png)\n存储器带宽：单位时间存储器所存取的信息量，一般以位/秒，字节/秒作为单位。\n# 高速缓冲存储器\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205201315.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205201833.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205202040.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205203321.png)\n### 例题 效率和时间\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205203456.png)\n## Cache（高速缓存）的实现\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205204038.png)\n### Cache映射\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205204412.png)\n#### 直接映射\n在直接映射中，**每个主存块** 映射到 **Cache** 中的一个固定位置。也就是说，每个主存块有一个唯一的Cache位置，它不可以被其他主存块占用。\n* 特点：\n\t- **映射方式简单**，只需要计算一个索引值来直接映射到Cache中的一个位置。\n\t- **容易实现**，硬件开销较小。\n\t- **冲突较多**，多个主存块可能会映射到相同的Cache位置，导致缓存未命中（Cache miss）增加。\n* 工作原理：\n\t- 主存地址分为 **标签（Tag）**、**索引（Index）** 和 **块内偏移（Block Offset）**。\n\t- **索引部分** 用来定位Cache中的某个块。\n\t- **标签部分** 用于验证主存块是否已经加载到Cache中的该位置。\n\t- **块内偏移** 用来定位块内部的数据。\n* 例子：\n\t* 假设Cache有4个块（4行），主存有16个块（16行），那么主存的每一个块可以映射到Cache中的一个固定位置。例如，主存的块0会映射到Cache的块0，主存的块1映射到Cache的块1，以此类推\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205204528.png)\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205210756.png)\n每个槽有个标志字段，用于指出该槽取自主存的哪个块群。主存共有128个块群。故标志位有7位。\n每个块群中的16块与Cache的16个槽一一对应。\n主存地址共20位：7位标志、4位槽号、9位字号。高7位标志表示该地址位于主存哪一个块群。\n访存过程：\nCPU给出20位主存地址，根据地址中间4位找到Cache相应的槽，然后取出该槽的标志，与地址中高7位进行比较。 若相等，则说明该主存单元所在的块在Cache中，再根据低9位字地址，从Cache的这一槽中取出字地址指出的那个单元送CPU；若不相等，则说明要访问的主存单元所在的那一块不在主存。此时将主存中该块调入Cache对应的槽中,并将该单元送CPU。\n\n#### 全相联\n在全相联映射中，主存中的任何块都可以映射到Cache中的任何位置。**没有固定的映射关系**，只要Cache有空闲的地方，主存中的任意块就可以加载到该位置。\n* 特点：\n\t- **灵活性高**，主存块可以映射到任何Cache位置，避免了直接映射中的冲突。\n\t- **访问冲突少**，适合某些访问模式不规则或不均匀的应用。\n\t- **实现复杂**，需要检查整个Cache（因为主存块可以在任何位置），硬件开销较大。\n\t- **硬件资源消耗高**，需要多路并行比较标签（Tag）。\n* 工作原理：\n\t- 主存地址分为 **标签（Tag）** 和 **块内偏移（Block Offset）**，没有索引部分。\n\t- **标签部分** 用于与Cache中的所有块进行匹配，确定该数据是否存在于Cache中。\n\t- **块内偏移** 用来定位块内部的数据。\n\n* 例子\n\t* 如果Cache有4个块（4行），主存有16个块，那么主存的任何一个块都可以被加载到Cache的任何一行。这种方式虽然避免了冲突，但会增加硬件比较的复杂度。\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205212549.png)\n* 访存过程：\n* CPU给出一个20位主存地址，根据高11位的内容同时与Cache中各槽的标志位进行比较。\n* 若能找到相等的槽，则说明要访问的单元在该槽中。再根据后9位字号找到相应的字取到CPU中。\n* 若全都不相等，则说明要访问的单元不在Cache中。\n#### ***必考*** 组相联映射 \n* 组相联映射结合直接映射和全相联映射的特点\n* 将Cache所有行分组，把主存块映射到Cache固定组的任一行中。也即：组间模映射(直接映射）、组内全映射。映射关系为：\n* Cache组号=主存块号 mod Cache组数\n\t* 举例：假定Cache划分为：8K字=8组x2行/组x512字/行\n\t* 4=100 mod 8\n\t* (主存第100块应映射到Cache的第4组的任意行中。)\n\n* 特点：\n\t* 结合直接映射（命中效率高）和全相联映射（命中率高）的优点。当Cache组数为1时，变为全相联映射；当每组只有一个槽时，变为直接映射。\n\t* 每组2或4行（称为2-路或4-路组相联）较常用。通常每组4行以上很少用。\n![image.png|800](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205214544.png)\n* 访存过程：\n* CPU给出一个20位主存地址，根据中间3位的内容找到对应的Cache组，再将前8位同时与该组中各槽的标志位进行比较。\n* 若能找到相等的槽，则说明要访问的单元在该槽中。再根据后9位字号找到相应的字取到CPU中。\n* 若全都不相等，则说明要访问的单元不在该组中。\n#### 三种方式比较\n## Cache数据访问过程与总容量\n[计组——彻底搞懂cache主存映射以及cache容量的计算_cache容量计算-CSDN博客](https://blog.csdn.net/vavid317/article/details/110946947)\n数据缓存使用1字节作为最小单位，而指令缓存使用1字作为最小单位。这是另一个例子，展示了字节选择被划分为块偏移和字节偏移。不同的计算机系统有不同的设计选择。这个示例中的设计对于指令缓存和数据缓存来说都很好。\n\n* 第一位一定是有效位，（一定有）固定占 **1** 位，由于cache未装进数据块时，主存字块标记默认为0，所以有效位是为了区分当前cache块是没装数据还是装了一个主存第0的数据\n* 由于Cache行数比主存块数少得多，因此Cache只能存放主存中的一部分信息，于是Cache要为每一块数据增加一个标记项，来指明它是主存中哪一块的副本，所以在计算cache容量时，需要同时分析标记项位数和cache数据块的位数。\n* cache行的位数＝cache行标记项位数＋cache块位数\n\n![image.png|600](https://eeecank-1325470508.cos.ap-shanghai.myqcloud.com/20241205215013.png)\n这道题中的有效位是1bit，标记位就是指令中的TAG位（标签位）的大小，用于比对该行是否存储的是指令中对应块群，相同意味着命中，否则不是\n这道题中的Cache行的位数：\n$$\n1bit(有效位)|16bit(标记位)|16*8bit(块的大小,用来存数据)=145b\n$$\n所以总的容量就是$145b\\times 4k=580kb=72.5KB$\n数据占就是$64KB/72.5KB=88.3\\%$\n直接映射中的标记位的大小就是: 主存地址位-Cache行-块内地址\n\n## 写策略（Cache一致性问题）\n* 为何要保持在Cache和主存中数据的一致？\n\t* 因为Cache中的内容是主存块副本，当对Cache中的内容进行更新时，就存在Cache和主存如何保持一致的问题。\n\t* 以下情况也会出现“Cache一致性问题”\n\t\t* 当多个设备都允许访问主存时\n\t\t* 例如：I/O设备可直接读写内存时，如果Cache中的内容被修改，则I/O设备读出的对应主存单元的内容无效；若I/O设备修改了主存单元的内容，则Cache中对应的内容无效。\n\t\t* 多个CPU都带有各自的Cache而共享主存时\n\t\t* 某个CPU修改了自身Cache中的内容，则对应的主存单元和其他CPU中对应的内容都变为无效。\n* 写操作有两种情况\n\t* 写命中（Write Hit）：要写的单元已经在Cache中\n\t* 写不命中（Write Miss）：要写的单元不在Cache中\n### 对于写命中，有两种处理方式\n* **Write Through(通写、全写、直写)\n\t* 同时写Cache和主存单元\n\t* 使用写缓冲（Write Buffer）\n\t* **优点**：简单，易于实现。由于每次写操作都会立即更新主存，确保了数据的一致性。\n\t- **缺点**：增加了主存的访问频率，可能会导致性能下降，尤其是对于频繁写入的程序。\n\t- **写缓冲（Write Buffer）**：为了减少对主存的写入延迟，通常会使用写缓冲。写缓冲是一个小型的高速存储区域，写操作首先写入缓冲区，然后缓冲区中的数据再按一定顺序写回主存。这样可以减少CPU和主存之间的直接交互，提高性能。\n* **Write Back (一次性写、写回、回写)\n\t*  只写cache不写主存，缺失时一次写回，每行有个修改位（“dirty bit-脏位”），大大降低主存带宽需求，控制可能很复杂\n\t* **优点**：减少了写入主存的频率，从而减少了主存带宽的需求，提高了性能。\n\t* **缺点**：实现上较复杂，需要管理脏位和Cache替换的策略，确保主存和Cache中的数据保持致。并且，在Cache满时，写回的操作会增加额外的延迟。\n\t* ***考点*** 采用此策略的时候Cache每行需要加入一个标记位(dirty bit 脏标记),此时行宽+1\n\n### 对于写不命中，有两种处理方式\n* **Write Allocate (写分配)**\n\t* 先更新主存块内容，然后将更新后的主存块装入Cache\n\t* 试图利用空间局部性，但每次都要从主存读一个块\n\t- **优点**：利用了空间局部性，可能会加速后续对该内存块的访问，因为数据块已经被加载到Cache中。\n\t- **缺点**：每次写操作都需要从主存读取数据块，这可能增加延迟，特别是在写操作频繁时\n* **Not Write Allocate (非写分配)**\n\t* 直接写主存单元，不把主存块装入到Cache\n\t- **优点**：避免了每次写操作都从主存加载数据块的延迟，减少了对Cache的占用。\n\t- **缺点**：可能降低Cache的命中率，因为没有将写入的块加载到Cache中，后续的读取请求可能会发生更多的Cache不命中。\n",
      "summary": "计算机组成原理的学习笔记",
      "cover": null,
      "authorId": 1,
      "likes_count": 1,
      "views_count": 18,
      "comments_count": 2,
      "bookmarks_count": 1,
      "tags": [
        "机组",
        "CS"
      ],
      "status": "published",
      "created_at": "2025-06-19T08:00:10.133804Z",
      "updated_at": "2025-06-19T08:11:19.698712Z",
      "author": {
        "id": 1,
        "username": "admin",
        "email": "admin@blog.com",
        "avatar": "/users/1/avatar.svg"
      },
      "is_liked": false,
      "is_bookmarked": false,
      "view_records": {
        "127.0.0.1": "2025-06-19T08:17:16.603713Z"
      }
    }
  ],
  "tags": [
    {
      "id": 1,
      "name": "Vue",
      "description": "Vue.js 前端框架相关内容",
      "color": "#4FC08D",
      "post_count": 1
    },
    {
      "id": 2,
      "name": "JavaScript",
      "description": "JavaScript 编程语言相关内容",
      "color": "#F7DF1E",
      "post_count": 1
    },
    {
      "id": 3,
      "name": "前端开发",
      "description": "前端开发技术和经验分享",
      "color": "#61DAFB",
      "post_count": 1
    },
    {
      "id": 4,
      "name": "Python",
      "description": "Python 编程语言相关内容",
      "color": "#3776AB",
      "post_count": 1
    },
    {
      "id": 5,
      "name": "FastAPI",
      "description": "FastAPI 框架相关内容",
      "color": "#009688",
      "post_count": 1
    },
    {
      "id": 6,
      "name": "后端开发",
      "description": "后端开发技术和经验分享",
      "color": "#FF5722",
      "post_count": 1
    },
    {
      "id": 7,
      "name": "API",
      "description": "API 设计和开发相关内容",
      "color": "#9C27B0",
      "post_count": 1
    },
    {
      "id": 8,
      "name": "UI设计",
      "description": "用户界面设计相关内容",
      "color": "#E91E63",
      "post_count": 1
    },
    {
      "id": 9,
      "name": "用户体验",
      "description": "用户体验设计和优化",
      "color": "#2196F3",
      "post_count": 1
    },
    {
      "id": 10,
      "name": "设计原则",
      "description": "设计理论和原则",
      "color": "#795548",
      "post_count": 1
    }
  ],
  "comments": [
    {
      "id": 1,
      "postId": 1,
      "authorId": 4,
      "content": "这篇文章写得很好！Composition API 确实比 Options API 更灵活。",
      "parentId": null,
      "likes": 5,
      "created_at": "2025-05-14T14:10:00.000000Z",
      "updated_at": "2024-06-10T12:00:00Z"
    },
    {
      "id": 2,
      "postId": 1,
      "authorId": 5,
      "content": "同意楼上的观点，特别是在大型项目中，Composition API 的优势更明显。",
      "parentId": 1,
      "likes": 3,
      "created_at": "2025-05-12T15:00:00.000000Z",
      "updated_at": "2024-06-10T13:30:00Z"
    },
    {
      "id": 3,
      "postId": 2,
      "authorId": 3,
      "content": "FastAPI 的自动文档生成功能真的很棒，大大提高了开发效率。",
      "parentId": null,
      "likes": 7,
      "created_at": "2025-05-05T13:45:00.000000Z",
      "updated_at": "2024-06-12T15:45:00Z"
    },
    {
      "id": 4,
      "postId": 3,
      "authorId": 1,
      "content": "设计原则总结得很全面，对新手设计师很有帮助。",
      "parentId": null,
      "likes": 4,
      "created_at": "2025-05-01T17:00:00.000000Z",
      "updated_at": "2024-06-14T10:20:00Z"
    },
    {
      "id": 5,
      "postId": 1,
      "authorId": 6,
      "content": "作为新手，这篇文章让我对 Composition API 有了更清晰的认识，谢谢分享！",
      "parentId": null,
      "likes": 2,
      "created_at": "2025-04-03T18:35:00.000000Z",
      "updated_at": "2024-06-16T09:30:00Z"
    },
    {
      "id": 6,
      "postId": 1,
      "authorId": 3,
      "content": "不客气！建议多动手实践，这样理解会更深刻。",
      "parentId": 5,
      "likes": 1,
      "created_at": "2025-04-03T15:38:00.000000Z",
      "updated_at": "2024-06-16T10:15:00Z"
    },
    {
      "id": 7,
      "postId": 2,
      "authorId": 5,
      "content": "FastAPI 的性能确实很不错，我们项目中也在使用。",
      "parentId": null,
      "likes": 6,
      "created_at": "2025-02-08T15:24:00.000000Z",
      "updated_at": "2024-06-13T08:20:00Z"
    },
    {
      "id": 8,
      "postId": 2,
      "authorId": 6,
      "content": "请问有推荐的 FastAPI 学习资源吗？",
      "parentId": 7,
      "likes": 0,
      "created_at": "2025-01-23T17:59:00.000000Z",
      "updated_at": "2024-06-16T11:00:00Z"
    },
    {
      "id": 9,
      "postId": 1,
      "authorId": 2,
      "content": "这是一条测试评论 1750231480",
      "parentId": null,
      "likes": 0,
      "created_at": "2025-01-22T17:54:00.000000Z",
      "updated_at": "2024-06-17T00:00:00Z"
    },
    {
      "id": 10,
      "postId": 1,
      "authorId": 2,
      "content": "这是一条测试评论 1750232721",
      "parentId": null,
      "likes": 0,
      "created_at": "2025-01-12T21:32:00.000000Z",
      "updated_at": "2024-06-17T00:00:00Z"
    },
    {
      "id": 11,
      "postId": 1,
      "authorId": 2,
      "content": "测试评论",
      "parentId": null,
      "likes": 0,
      "created_at": "2025-05-14T14:10:00.000000Z",
      "updated_at": "2024-06-17T00:00:00Z"
    },
    {
      "id": 12,
      "postId": 1,
      "authorId": 2,
      "content": "继续测试",
      "parentId": 11,
      "likes": 0,
      "created_at": "2025-05-12T15:00:00.000000Z",
      "updated_at": "2024-06-17T00:00:00Z"
    },
    {
      "id": 13,
      "postId": 7,
      "authorId": 1,
      "content": "你好",
      "parentId": null,
      "likes": 0,
      "created_at": "2025-05-05T13:45:00.000000Z",
      "updated_at": "2024-06-17T00:00:00Z"
    },
    {
      "id": 14,
      "postId": 10,
      "authorId": 1,
      "content": "计算机组成原理实在是太重要了啊",
      "parentId": null,
      "likes": 0,
      "created_at": "2025-06-19T08:17:33.218900Z",
      "updated_at": "2025-06-19T08:17:33.218900Z"
    },
    {
      "id": 15,
      "postId": 10,
      "authorId": 1,
      "content": "一定要好好学习啊",
      "parentId": 14,
      "likes": 0,
      "created_at": "2025-06-19T08:17:47.754606Z",
      "updated_at": "2025-06-19T08:17:47.754606Z"
    }
  ],
  "follows": [
    {
      "id": 2,
      "followerId": 3,
      "followingId": 1,
      "created_at": "2025-06-14T09:15:00.000000Z"
    },
    {
      "id": 3,
      "followerId": 4,
      "followingId": 3,
      "created_at": "2025-06-14T09:04:00.000000Z"
    },
    {
      "id": 6,
      "followerId": 6,
      "followingId": 1,
      "created_at": "2025-05-13T13:09:00.000000Z"
    },
    {
      "id": 8,
      "followerId": 7,
      "followingId": 1,
      "created_at": "2025-04-15T11:12:00.000000Z"
    },
    {
      "id": 9,
      "followerId": 7,
      "followingId": 3,
      "created_at": "2025-03-23T16:43:00.000000Z"
    },
    {
      "id": 10,
      "followerId": 7,
      "followingId": 4,
      "created_at": "2025-02-05T13:51:00.000000Z"
    },
    {
      "id": 11,
      "followerId": 7,
      "followingId": 5,
      "created_at": "2025-06-18T19:56:00.000000Z"
    },
    {
      "id": 12,
      "followerId": 1,
      "followingId": 4,
      "created_at": "2025-06-14T09:15:00.000000Z"
    }
  ],
  "notifications": [
    {
      "id": 1,
      "userId": 1,
      "type": "follow",
      "title": "新的关注者",
      "content": "前端开发者 关注了你",
      "relatedId": 3,
      "relatedType": "user",
      "isRead": true,
      "created_at": "2025-05-22T11:23:00.000000Z"
    },
    {
      "id": 2,
      "userId": 3,
      "type": "comment",
      "title": "新的评论",
      "content": "后端工程师 评论了你的文章《Vue 3 Composition API 完全指南》",
      "relatedId": 1,
      "relatedType": "post",
      "isRead": false,
      "created_at": "2025-05-18T21:52:00.000000Z"
    },
    {
      "id": 3,
      "userId": 3,
      "type": "follow",
      "title": "新的关注者",
      "content": "????? 关注了你",
      "relatedId": 1,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-04-13T12:29:00.000000Z"
    },
    {
      "id": 4,
      "userId": 3,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-04-12T20:40:00.000000Z"
    },
    {
      "id": 5,
      "userId": 1,
      "type": "follow",
      "title": "新的关注者",
      "content": "新手程序员 关注了你",
      "relatedId": 6,
      "relatedType": "user",
      "isRead": true,
      "created_at": "2025-04-07T19:50:00.000000Z"
    },
    {
      "id": 6,
      "userId": 4,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-03-12T22:26:00.000000Z"
    },
    {
      "id": 7,
      "userId": 1,
      "type": "follow",
      "title": "新的关注者",
      "content": "111@qq.com 关注了你",
      "relatedId": 7,
      "relatedType": "user",
      "isRead": true,
      "created_at": "2025-03-10T17:52:00.000000Z"
    },
    {
      "id": 8,
      "userId": 3,
      "type": "follow",
      "title": "新的关注者",
      "content": "111@qq.com 关注了你",
      "relatedId": 7,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-02-10T18:02:00.000000Z"
    },
    {
      "id": 9,
      "userId": 4,
      "type": "follow",
      "title": "新的关注者",
      "content": "111@qq.com 关注了你",
      "relatedId": 7,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-01-15T21:54:00.000000Z"
    },
    {
      "id": 10,
      "userId": 5,
      "type": "follow",
      "title": "新的关注者",
      "content": "111@qq.com 关注了你",
      "relatedId": 7,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-01-13T08:27:00.000000Z"
    },
    {
      "id": 11,
      "userId": 4,
      "type": "follow",
      "title": "新的关注者",
      "content": "????? 关注了你",
      "relatedId": 1,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-05-22T11:23:00.000000Z"
    },
    {
      "id": 12,
      "userId": 2,
      "type": "follow",
      "title": "新的关注者",
      "content": "admin 关注了你",
      "relatedId": 1,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T18:22:58.811224Z"
    },
    {
      "id": 13,
      "userId": 2,
      "type": "follow",
      "title": "新的关注者",
      "content": "admin 关注了你",
      "relatedId": 1,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T18:25:29.997072Z"
    },
    {
      "id": 14,
      "userId": 2,
      "type": "follow",
      "title": "新的关注者",
      "content": "admin 关注了你",
      "relatedId": 1,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T18:25:32.330040Z"
    },
    {
      "id": 15,
      "userId": 2,
      "type": "follow",
      "title": "新的关注者",
      "content": "admin 关注了你",
      "relatedId": 1,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T18:49:24.367310Z"
    },
    {
      "id": 16,
      "userId": 1,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T18:58:36.820064Z"
    },
    {
      "id": 17,
      "userId": 5,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T19:23:44.327083Z"
    },
    {
      "id": 18,
      "userId": 5,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T19:26:44.520740Z"
    },
    {
      "id": 19,
      "userId": 5,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T19:26:46.476419Z"
    },
    {
      "id": 20,
      "userId": 5,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T19:26:48.019518Z"
    },
    {
      "id": 21,
      "userId": 5,
      "type": "follow",
      "title": "新的关注者",
      "content": "user1 关注了你",
      "relatedId": 2,
      "relatedType": "user",
      "isRead": false,
      "created_at": "2025-06-18T19:26:51.266176Z"
    }
  ],
  "likes": [
    {
      "id": 2,
      "userId": 2,
      "postId": 1,
      "created_at": "2025-06-01T21:40:00.000000Z"
    },
    {
      "id": 3,
      "userId": 3,
      "postId": 2,
      "created_at": "2025-05-06T18:42:00.000000Z"
    },
    {
      "id": 4,
      "userId": 4,
      "postId": 3,
      "created_at": "2025-04-06T20:58:00.000000Z"
    },
    {
      "id": 5,
      "userId": 1,
      "postId": 9,
      "created_at": "2025-06-18T18:09:18.791579Z"
    },
    {
      "id": 6,
      "userId": 1,
      "postId": 10,
      "created_at": "2025-06-19T08:17:53.609680Z"
    }
  ],
  "bookmarks": [
    {
      "id": 1,
      "userId": 1,
      "postId": 2,
      "created_at": "2025-06-06T12:32:00.000000Z"
    },
    {
      "id": 2,
      "userId": 2,
      "postId": 1,
      "created_at": "2025-05-17T16:11:00.000000Z"
    },
    {
      "id": 3,
      "userId": 3,
      "postId": 3,
      "created_at": "2025-05-16T20:55:00.000000Z"
    },
    {
      "id": 4,
      "userId": 2,
      "postId": 3,
      "created_at": "2025-05-16T16:08:00.000000Z"
    },
    {
      "id": 5,
      "userId": 7,
      "postId": 1,
      "created_at": "2025-04-09T12:56:00.000000Z"
    },
    {
      "id": 7,
      "userId": 7,
      "postId": 4,
      "created_at": "2025-04-09T12:50:00.000000Z"
    },
    {
      "id": 9,
      "userId": 7,
      "postId": 3,
      "created_at": "2025-03-20T18:54:00.000000Z"
    },
    {
      "id": 10,
      "userId": 7,
      "postId": 7,
      "created_at": "2025-03-10T22:34:00.000000Z"
    },
    {
      "id": 11,
      "userId": 2,
      "postId": 9,
      "created_at": "2025-06-18T12:56:55.587452Z"
    },
    {
      "id": 12,
      "userId": 1,
      "postId": 9,
      "created_at": "2025-06-19T06:57:20.092769Z"
    },
    {
      "id": 13,
      "userId": 1,
      "postId": 10,
      "created_at": "2025-06-19T08:17:54.354280Z"
    }
  ],
  "categories": [
    {
      "id": 1,
      "name": "技术分享",
      "description": "技术相关的文章和教程",
      "post_count": 2
    },
    {
      "id": 2,
      "name": "设计相关",
      "description": "UI/UX设计相关内容",
      "post_count": 1
    },
    {
      "id": 3,
      "name": "经验总结",
      "description": "工作和学习经验的总结",
      "post_count": 0
    }
  ],
  "anonymous_messages": [
    {
      "id": 1,
      "content": "这是第一条匿名消息，大家可以在这里自由交流想法！",
      "created_at": "2025-06-18T10:30:00.000000Z",
      "ip_hash": "a1b2c3d4e5f6",
      "is_deleted": false
    },
    {
      "id": 2,
      "content": "匿名频道真是个好想法，可以让大家更自由地表达观点。",
      "created_at": "2025-06-18T11:15:00.000000Z",
      "ip_hash": "f6e5d4c3b2a1",
      "is_deleted": false
    },
    {
      "id": 3,
      "content": "有人知道最新的前端技术趋势吗？想了解一下。",
      "created_at": "2025-06-18T12:00:00.000000Z",
      "ip_hash": "1a2b3c4d5e6f",
      "is_deleted": false
    },
    {
      "id": 4,
      "content": "推荐大家学习 TypeScript，真的很有用！",
      "created_at": "2025-06-18T12:45:00.000000Z",
      "ip_hash": "6f5e4d3c2b1a",
      "is_deleted": false
    },
    {
      "id": 5,
      "content": "有没有人想组队做开源项目的？",
      "created_at": "2025-06-18T13:20:00.000000Z",
      "ip_hash": "b1a2c3d4e5f6",
      "is_deleted": false
    },
    {
      "id": 6,
      "content": "这是一条测试匿名消息，来自API测试！",
      "created_at": "2025-06-18T14:17:55.262084Z",
      "ip_hash": "f528764d624d",
      "is_deleted": true,
      "deleted_at": "2025-06-18T14:21:16.404718Z",
      "deleted_by": 1
    },
    {
      "id": 7,
      "content": "测试匿名消息",
      "created_at": "2025-06-18T18:10:27.122570Z",
      "ip_hash": "f528764d624d",
      "is_deleted": true,
      "deleted_at": "2025-06-18T18:24:11.342647Z",
      "deleted_by": 1
    }
  ]
}